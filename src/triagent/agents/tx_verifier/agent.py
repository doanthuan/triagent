"""
Agent classes for the Medical Fact Verifier system using Google ADK.
Implements the multi-agent architecture for fact-checking medical claims.
"""
import sys
sys.path.append("../../")

import time
from typing import Any, AsyncGenerator

from google.adk.agents import LlmAgent, SequentialAgent
from google.adk.agents.invocation_context import InvocationContext
from google.adk.events.event import Event, EventActions
from google.adk.tools import google_search
from typing_extensions import override

from triagent.agents.tx_verifier.prompts import (
    claim_extractor_prompt,
    double_check_prompt,
    fact_check_prompt,
)
from triagent.agents.tx_verifier.tools import search_exa_literature
from triagent.agents.tx_verifier.utils import parse_json_safe
from triagent.logging import logger

GEMINI_MODEL = "gemini-2.5-pro-preview-05-06"

# --- 1. Define Sub-Agents for Each Pipeline Stage ---
# Claim Extractor Agent
claim_extractor_agent = LlmAgent(
    name="claim_extractor_agent",
    model=GEMINI_MODEL,
    instruction=claim_extractor_prompt,
    description="Extracts medical claims from a paragraph.",
    output_key="claims",  # Stores output in state['claims']
)

# Fact Checker Agent with Google Search Tool
# Takes the claims generated by the previous agent (read from state) and checks the fact of each claim.
fact_check_agent = LlmAgent(
    name="fact_check_agent",
    model=GEMINI_MODEL,
    instruction=fact_check_prompt,
    description="Checks the fact of each claim.",
    tools=[google_search],
    output_key="fact_check_results",  # Stores output in state['fact_check_results']
)


# Double-Check Agent with Exa tool
# Takes the claims generated by the previous agent (read from state) and checks the fact of each claim.
double_check_agent = LlmAgent(
    name="double_check_agent",
    model=GEMINI_MODEL,
    instruction=double_check_prompt,
    description="Checks the fact of each claim.",
    tools=[search_exa_literature],
    output_key="double_check_results",  # Stores output in state['double_check_results']
)


class FactVerifierOrchestrator(SequentialAgent):
    """
    Main orchestrator agent that coordinates the entire fact-checking workflow.
    Implements the sequential workflow: Claim Extraction → Fact Verification → Double Check.
    """

    claim_extractor_agent: LlmAgent
    fact_check_agent: LlmAgent
    double_check_agent: LlmAgent

    model_config = {"arbitrary_types_allowed": True}

    def __init__(self) -> None:
        super().__init__(
            name="fact_check_pipeline_agent",
            description="Executes a sequence of fact checking.",
            claim_extractor_agent=claim_extractor_agent,
            fact_check_agent=fact_check_agent,
            double_check_agent=double_check_agent,
        )

    @override
    async def _run_async_impl(
        self, ctx: InvocationContext
    ) -> AsyncGenerator[Event, None]:
        logger.info(f"[{self.name}] Starting fact checking workflow.")
        logger.info(f"[Initial State: {ctx.session.state}")

        # Step 1: Extract claims
        logger.info(f"[{self.name}] Running Extract Claims Agent...")
        async for event in self.claim_extractor_agent.run_async(ctx):
            logger.info(
                f"[{self.name}] Event from Claim Extractor Agent: {event.model_dump_json(indent=2, exclude_none=True)}"
            )
            yield event

        # Step 2: Fact check claims
        logger.info(f"[{self.name}] Running Fact Check Agent...")
        async for event in self.fact_check_agent.run_async(ctx):
            logger.info(
                f"[{self.name}] Event from Fact Check Agent: {event.model_dump_json(indent=2, exclude_none=True)}"
            )
            yield event

        # Step 2 post processing case 1: no fact check results
        if "fact_check_results" not in ctx.session.state:
            logger.error(
                f"[{self.name}] Failed to generate fact check results. Aborting workflow."
            )
            return  # Stop processing if fact check results are not generated

        # Step 2 post processing case 2: no claims in fact check results
        fact_check_results = parse_json_safe(ctx.session.state["fact_check_results"])
        logger.info(f"Fact Check Results: {fact_check_results}")
        if fact_check_results is None or "claims" not in fact_check_results:
            logger.error(
                f"[{self.name}] Failed to parse fact check results. Aborting workflow."
            )
            return  # Stop processing if fact check results are not generated

        # Step 2 post processing case 3: no claims to double check
        claims = fact_check_results["claims"]
        cannot_verified_claims = [
            claim["claim"]
            for claim in claims
            if claim["verified"] in ["Cannot verify", "Incorrect"]
        ]
        if len(cannot_verified_claims) == 0:
            logger.info(f"[{self.name}] No claims to double check.")
            yield self._create_final_event(fact_check_results, ctx)
            return  # Stop processing if no claims to double check

        # Step 3: Double check claims
        logger.info(f"[{self.name}] Cannot verified claims: {cannot_verified_claims}")
        ctx.session.state["cannot_verified_claims"] = cannot_verified_claims
        logger.info(f"[{self.name}] Running Double Check Agent...")
        async for event in self.double_check_agent.run_async(ctx):
            logger.info(
                f"[{self.name}] Event from Double Check Agent: {event.model_dump_json(indent=2, exclude_none=True)}"
            )
            yield event

        # Step 4: Combine results
        if "double_check_results" not in ctx.session.state:
            logger.info(
                f"[{self.name}] No double check results found. Using fact check results only."
            )
            final_results = ctx.session.state["fact_check_results"]
        else:
            logger.info(f"[{self.name}] Combining results...")
            final_results = self.combine_results(
                ctx.session.state["fact_check_results"],
                ctx.session.state["double_check_results"],
            )

        logger.info(f"[{self.name}] Final results: {final_results}")

        yield self._create_final_event(final_results, ctx)

        logger.info(f"[{self.name}] Workflow finished.")

    def _create_final_event(self, final_results: Any, ctx: InvocationContext) -> Event:
        """
        Raises a final event with the final results.
        """
        # --- Create Event with Actions ---
        state_changes = {"final_results": final_results}
        actions_with_update = EventActions(state_delta=state_changes)
        system_event = Event(
            invocation_id=ctx.invocation_id,
            author="system",  # Or 'agent', 'tool' etc.
            actions=actions_with_update,
            timestamp=time.time(),
        )
        return system_event

    def combine_results(self, fact_check_results, double_check_results) -> Any:
        """
        Combines results from initial fact check and double check verification.

        Args:
            fact_check_results (dict): Results from initial fact checking
            double_check_results (dict): Results from double check verification

        Returns:
            dict: Combined results with updated verification status
        """
        # Parse the JSON strings if they are strings
        fact_check = (
            parse_json_safe(fact_check_results)
            if isinstance(fact_check_results, str)
            else fact_check_results
        )
        double_check = (
            parse_json_safe(double_check_results)
            if isinstance(double_check_results, str)
            else double_check_results
        )

        if not fact_check or not double_check:
            logger.error(
                "[FactVerifier] Failed to parse fact check or double check results"
            )
            return fact_check_results

        # Create a mapping of claims to their double check results for easy lookup
        double_check_map = {
            claim["claim"]: claim for claim in double_check.get("claims", [])
        }

        # Update the original claims with double check results
        for claim in fact_check.get("claims", []):
            original_claim = claim["claim"]
            if original_claim in double_check_map:
                double_check_claim = double_check_map[original_claim]
                # Update verification status if double check provides new information
                if double_check_claim["verified"] == "Correct":
                    claim["verified"] = "Partially correct"
                    claim["explanation"] = double_check_claim["explanation"]
                    claim["evidence"] = double_check_claim["evidence"]
                    claim["evidence_url"] = double_check_claim["evidence_url"]
                    claim["confidence_level"] = double_check_claim["confidence_level"]

        return fact_check

root_agent = FactVerifierOrchestrator()